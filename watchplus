#!/usr/bin/python
# pylint: disable=line-too-long, missing-docstring , attribute-defined-outside-init, too-many-lines, fixme
# pylint: disable=invalid-name, no-else-return, redifined-outer-name, too-many-statements, bare-except
from __future__ import print_function

# -*- encoding: utf8 -*-

import os
import sys
import subprocess
import multiprocessing
import threading
import time
import timeit
import datetime
import argparse
import traceback
import bisect
import string
import shlex
import fcntl
import bz2
from time import sleep as _sleep

try:
    # sys.intern() in python3, just intern() in python2
    from sys import intern
except ImportError:
    pass
try:
    # sys.exc_clear in python2, not python3. don't really need it in python3
    from sys import exc_clear  # pylint: disable= unused-import
except ImportError:
    throw_away = lambda *args, **kwargs: 1
    sys.exc_clear = throw_away
try:
    import curses
except ImportError:
    print("Unable to load python-curses. You may need to install the package on the OS (yum install python-curses).")
    sys.exit()
try:
    # python 2 import cpickle, python 3 already cpickle
    import cPickle as pickle
except ImportError:
    import pickle


# ======================================================================================================================
#   Arguments and flags
# ======================================================================================================================

MAX_COMMANDS = 20
MAX_LINE_LENGTH = 10000

def process_argparse():
    # first split all command line args based on -- only
    cl_argv_split = split_command_line_argv()

    # get command line commands
    source = "command line"
    cl_system_args, cl_command_args = extract_system_command_args(cl_argv_split, source)

    if cl_system_args.open:
        Settings.load_saved_run = True
        Settings.load_run_file = cl_system_args.open.name
        return

    # process -f file args
    f_system_args = []
    f_command_args = []
    if cl_system_args.arg_file:
        f_argv_split = read_file_args(cl_system_args.arg_file)

        # read command args and more system args from file if exists
        source = cl_system_args.arg_file.name
        f_system_args, f_command_args = extract_system_command_args(f_argv_split, source)

    # command line system args take precedence over file system args
    system_args = merge_namespace(f_system_args, cl_system_args)

    # file commands take precedence over command line commands, too confusing otherwise
    command_args = f_command_args + cl_command_args

    commands_assigned, commands_unassigned = assign_commands_to_tabs(command_args)

    print_commands(commands_assigned, commands_unassigned)
    validate_args(system_args, commands_assigned)
    store_args_in_settings(system_args, commands_assigned, commands_unassigned)

def merge_namespace(first, precedence):
    if first and precedence:
        new = vars(first)
        new.update(vars(precedence))
        return argparse.Namespace(**new)
    return first if first else precedence

def split_command_line_argv():
    argv_split = [[]]
    for argv in sys.argv[1:]:
        # split into command groups based on --, it's the only way argparse can handle it
        if argv == "-h" or argv == "--help":
            print_help()
            sys.exit()
        elif argv == "--":
            argv_split.append([])
        elif argv.startswith("-") and argv in argv_split[-1]:
            message = "duplicate {}, perhaps missing '--' separator".format(argv)
            raise argparse.ArgumentError(None, message)
        else:
            argv_split[-1].append(argv)

    return argv_split

def extract_system_command_args(argv_split, source):
    """
    :return: system_args = argparse.Namespace
             command_args = [argparse.Namespace,...]
    """
    system_args = None
    command_args = []

    # strip out system options as an argparse.Namespace
    parser = init_system_parser()
    add_system_args(parser)
    namespace = None
    for count, argv in enumerate(argv_split):
        arg = parser.parse_known_args(args=argv, namespace=namespace)
        system_args = arg[0]
        # namspace is used to preserve "running total" of sys args
        namespace = system_args
        argv_split[count] = arg[1]

    # convert
    for argv in argv_split:
        if argv:
            parser = init_command_parser()
            add_command_args(parser)
            command_args.append(parser.parse_args(args=argv))
            command_args[-1].source = source
            command_args[-1].original = argv

    return system_args, command_args

def read_file_args(arg_file_object):
    argv_split = []
    with arg_file_object as f:
        for line in f:
            argv_split.append(shlex.split(line, comments=True))
    argv_split = list(filter(len, argv_split))
    return argv_split

def assign_commands_to_tabs(command_args):
    """
    :return: [argparse.Namespace,...] note: len = 40, can contain None values throughout because of
            manual assignment flag
    """
    tab_text = {1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: '0',
                11: 'shift-1', 12: 'shift-2', 13: 'shift-3', 14: 'shift-4', 15: 'shift-5', 16: 'shift-6',
                17: 'shift-7', 18: 'shift-8', 19: 'shift-9', 20: 'shift-0'}
    commands_assigned = [None] * MAX_COMMANDS
    commands_temp = []
    commands_unassigned = []

    # first assign to tab commands with -t option and put all remaining in commands_temp
    for command in command_args:
        tab = command.tab
        if tab and tab > 0 and tab <= MAX_COMMANDS:
            if not commands_assigned[tab - 1]:
                commands_assigned[tab - 1] = command
                continue
        commands_temp.append(command)

    for command in commands_temp:
        for count, tab in enumerate(commands_assigned):
            if not tab:
                commands_assigned[count] = command
                break
        else:
            commands_unassigned.append(command)

    for count, command in enumerate(commands_assigned):
        if command:
            p = "tab {:8}: {} from {}"
            commands_assigned[count].print = p.format(tab_text[count + 1], command.original, command.source)
    for count, command in enumerate(commands_unassigned):
        p = "exceeded {} cmds, not using {} from {}"
        commands_unassigned[count].print = p.format(MAX_COMMANDS, command.original, command.source)

    return commands_assigned, commands_unassigned

def print_commands(commands_assigned, commands_unassigned):
    for command in commands_assigned:
        if command:
            print(command.print)
    for command in commands_unassigned:
        print(command.print)

def validate_args(system_args, commands_assigned):
    if not [c for c in commands_assigned if c]:
        message = "No commands found."
        raise argparse.ArgumentError(None, message)

    if system_args.interval < .01:
        raise argparse.ArgumentError(None, "Interval cannot be less than .01.")

def store_args_in_settings(system_args, commands_assigned, commands_unassigned):
    Settings.interval = system_args.interval
    Settings.timeout = min(.1, Settings.interval * .4)
    Settings.precision = system_args.precision
    Settings.run_path = os.path.expanduser('~/')
    Settings.run_compression = True
    Settings.max_line_length = MAX_LINE_LENGTH

    for count, command in enumerate(commands_assigned):
        if command:
            Settings.commands[count] = vars(command)["\"cmd\""]
            Settings.bottom_bar_label[count] = "".join([x for x in Settings.commands[count] if x in Settings.printable])
            Settings.streaming[count] = command.streaming
            Settings.glue_bottom[count] = command.glue_bottom
            Settings.no_change[count] = command.no_change
            Settings.window_ids.append(count)
            Settings.commands_assigned.append(command.print)
    for command in enumerate(commands_unassigned):
        Settings.commands_unassigned.append(command.print)
    Settings.start_window_id = Settings.window_ids[0]

def print_help():
    parser = init_system_parser()
    add_system_args(parser)
    add_command_args(parser)
    parser.print_help()

def init_system_parser():
    terminal_width = int(run_linux("tput cols")[0])
    format_func = lambda prog: argparse.RawTextHelpFormatter(prog, width=terminal_width - 2, max_help_position=32)
    usage = "%(prog)s [-o <f>] | [-f <f>] | [sys options] [cmd options] \"cmd\" [ -- [cmd options] \"cmd\" ]..."
    description = "%(prog)s - a better watch. Featuring pause, rewind and forward, scrolling up and down, line " \
    "wrapping, multiple tabs running indivudal commands simultaneously, and saving runs. Also supports " \
    "streaming commands such as ping and tcpdump."
    epilog = """
Keys controlling playback and viewing:
  Playback controls (all tabs at once):
     Space ............................... Play | Pause  (does not stop recording)
     r ................................... Start | Stop recording Frames
     A a s | d f F ....................... 100 | 10 | 1 << >> 1 | 10 | 100  Frames
     Left | Right Arrows (ctrl, shift) ... 100 | 10 | 1 << >> 1 | 10 | 100  Frames
     w | e ............................... First << >> Last  Frames
  Viewing controls:
     1-0, shift 1-0 ...................... Change tab
                                           1-0 = tab 1-10, shft-1-0 = tab 11-20
     x ................................... Toggle change history display on/off
     k j ................................. Up | Down
     Up | Down Arrows .................... Up | Down
     Ctrl-u | Ctrl-d ..................... Half page up | down
     Ctrl-b | Ctrl-f ..................... Page up | down
     Page-Up | Page-Down ................. Page up | down
     g | G ............................... Top | Bottom
  Other controls:
     crtl-w .............................. Write frames and tabs to ~/[date_time].wp
                                           Stops recording during write. Load: -o <f>
     crtl-h .............................. View this help and tab assignments
     ctrl-c .............................. Quit"""
    Settings._help = epilog

    return argparse.ArgumentParser(formatter_class=format_func,
                                   description=description,
                                   usage=usage,
                                   epilog=epilog,
                                   add_help=False)

def init_command_parser():
    return argparse.ArgumentParser()

def add_system_args(parser):
    group = parser.add_argument_group("Run file")
    group.add_argument("-o", "--open", dest="open", type=argparse.FileType('r'), metavar="<f>",
                       help="Load %(prog)s run file <f> that was saved from a past run.\n"
                            "Use ctrl-w after a run to save to a run file.")

    group = parser.add_argument_group("Setup File")
    group.add_argument("-f", "--file", dest="arg_file", type=argparse.FileType('r'), metavar="<f>",
                       help="Read [sys options] [cmd options] \"cmd\" from file <f>.\n"
                            "One command per line. Example:\n-n 1 -p\n\"dmesg\"\n-s \"ping -4 1.1.1.1\"")

    group = parser.add_argument_group("System options (applies to all tabs)")
    group.add_argument("-n", "--interval", dest="interval", type=float, metavar="<s>", default=1.0,
                       help="Interval in <seconds>, minimum .01, default = 1.0.")
    group.add_argument("-p", "--precise", dest="precision", action="store_true",
                       help="Attempt to maintain interval, drop frame if not completed in time.")
    group.add_argument("-h", "--help", dest="show_help", action="store_true",
                       help="Show this help.")

def add_command_args(parser):
    group = parser.add_argument_group("Command options")
    group.add_argument("--", dest="separator", action="store_true",
                       help="Separator for commands on command line. Not needed for the first one.\n"
                            "Example: %(prog)s -n 1 \"dmesg\" -- -s \"ping -4 1.1.1.1\" -- \"nstat\"")
    group.add_argument("-s", "--streaming", dest="streaming", action="store_true",
                       help="For use with continual streaming commands such as tcpdump and ping.")
    group.add_argument("-b", "--bottom", dest="glue_bottom", action="store_true",
                       help="Start this tab at the bottom of the output, similar to follow option.")
    group.add_argument("-x", "--change", dest="no_change", action="store_true",
                       help="Do not display change history. Can be toggled on/off with 'x'.")
    group.add_argument("-t", "--tab", dest="tab", type=int, metavar="<t>",
                       help="Assign this command to tab <t> if possible, 1-{}.\n".format(MAX_COMMANDS))
    group.add_argument("\"cmd\"", help="Command to be run, up to {} allowed, each in in a separate tab.\n"
                                       "Note: enclose in DOUBLE quotes with inside escaped quotes as needed.".
                       format(MAX_COMMANDS))

class Settings(object):
    printable = string.digits + string.punctuation + string.ascii_letters + " "
    commands = [None] * MAX_COMMANDS
    commands_assigned = [None]
    commands_unassigned = []
    bottom_bar_label = [None] * MAX_COMMANDS
    streaming = [None] * MAX_COMMANDS
    glue_bottom = [None] * MAX_COMMANDS
    no_change = [None] * MAX_COMMANDS
    window_ids = []
    window_id_help = 0
    interval = 1
    timeout = .4
    precision = False
    start_window_id = 0
    run_path = ""
    run_compression = True
    max_line_length = MAX_LINE_LENGTH
    load_saved_run = False
    load_run_file = ""
    _help = ""

    @classmethod
    def __getstate__(cls):
        # this is needed to pickle class variables. Skip private variables and methods
        return {var_name: cls.__dict__[var_name] for var_name in cls.__dict__ if not var_name.startswith("_")}

    @classmethod
    def __setstate__(cls, state):
        for var_name, value in state.items():
            setattr(cls, var_name, value)

class Debug():
    """ Place Debug.debug_to_file(message, message, etc.) anywhere message will be output to debug_file.
    decorate a method with @Debug.debug_timer the time will be recorded to debug_file.
    """
    debug_generator = True
    debug_generator = False
    debug_frame_controller = False
    debug_text_only = True
    debug_text_only = False
    debug_event_controller = False

    debug_file = "debug"
    debug_file_clear = True

    @classmethod
    def debug_to_file(cls, *message):
        if cls.debug_file_clear:
            try:
                os.remove(cls.debug_file)
            except:
                pass
            cls.debug_file_clear = False

        # enhance: change this to logging
        with open(cls.debug_file, "a") as f:
            for item in message:
                f.write(str(item) + " ")
            f.write(" \n")

    @classmethod
    def debug_timer(cls, func):
        # decorate a method with @Debug.debug_timer
        def wrapper_timer(*args, **kwargs):
            start = timeit.default_timer()
            func(*args, **kwargs)
            stop = timeit.default_timer()
            cls.debug_to_file(func.__name__, " time to complete: ", stop - start)
            # print(func.__name__, " time to complete: ", stop - start)
            return func(*args, **kwargs)
        return wrapper_timer


# ======================================================================================================================
#   Frame Controller, drawing the output, moving around, switching tabs (windows)
# ======================================================================================================================

class FrameControllers(object):
    """This is the main controlling class.

       Frames are merely the collection of the stdout (or stderr) of the target command or script. If the target
       command or script is run every second for 10 seconds, 10 frames (outputs) will be generated and stored.
       Heatmaps are numerical representation for the change state of each character in a frame, it's the highlighting
       that occurs when a character changes from one frame to the next. See the FrameGenerators class for more details.

       This class is utilized inside a multiprocess subprocess, one subprocess for each target command or script.

       Class data can only be accessed from within the subprocess, multiprocess queues are utilized to share data between
       processes.
       """

    def __getstate__(self):
        includes = [
        "lines_chars",
        "lines_chars_pointers",
        "lines",
        "lines_states",
        "lines_pointers",
        "lines_lengths",
        "frame_length",
        "frame_state",
        "heatmap_state",
        "frame_date_time",
        "current",
        "new",
        "streaming"]
        return {var_name: self.__dict__[var_name] for var_name in self.__dict__ if var_name in includes}

    def __setstate__(self, state):
        self.__dict__.update(state)

    def common_init(self):
        self.event = None
        self.max_line_length = Settings.max_line_length
        self.max_line_length_message = " ...MAX LINE LENGTH EXCEEDED ({})!!".format(self.max_line_length)
        self.max_line_length_total = len(self.max_line_length_message) + self.max_line_length

        # window fields
        self.draw_height_adder = 0
        self.draw_width_adder = 0
        self.terminal_draw_height = 0
        self.terminal_draw_width = 0
        self.window = None
        self.terminal_height = 0
        self.terminal_width = 0
        self.y_top_line = 0
        self.y_top_sub = 0
        self.draw_move = 0
        self.resize = 0
        self.next_playback = 0
        self.playback_speed = 1.0
        self.next_frame_type = "first"
        self.next_heatmap_type = "first"

    def frame_init(self):
        # frame fields
        self.lines_chars = []
        self.lines_chars_pointers = []
        self.lines = []
        self.lines_states = []
        self.lines_pointers = []
        self.lines_lengths = []
        self.frame_length = []
        self.frame_state = []
        self.heatmap_state = []
        self.frame_date_time = []
        self.current = - 1
        self.new = -1

        self.draw_current = -2
        self.draw_state = "play"
        self.recording_state = "record"

    def event_init(self):
        self.event_choices = {
            "start new frame": self.start_new_frame,  # comes from event controller self.event_queue
            "new frame": self.received_new_frame_notice_from_generator,      # comes from frame generator self.event_queue
            "window change": self.window_change,
            "refresh": self.draw_refresh,
            "back": self.draw_back,
            "forward": self.draw_forward,
            "window move": self.move_window,
            "toggle draw state": self.draw_state_toggle,
            "toggle recording": self.toggle_recording,
            "playback speed": self.set_playback_speed,
            "toggle change": self.toggle_change,
            "clear history": self.clear_history,
            "save": self.write_to_file}

    def initialize_generator_childprocess(self):
        self.process_generator = None
        self.generator_seed = FrameGenerators()
        self.generator_frame_queue = multiprocessing.Queue(0)
        self.generator_event_queue = multiprocessing.Queue(0)
        self.process_generator = multiprocessing.Process(
            target=self.generator_seed.generator_controller,
            args=(
                self.command,
                self.generator_frame_queue,
                self.generator_event_queue,
                self.event_queue,
                self.streaming
            ))
        self.process_generator.start()

    def frame_controller(self, window_id, event_queue, system_queue, frame_draw_current_queue, frame_draw_state_queue):
        """ This is the main method that controls storing and drawing frames. First, it spawns a never
            ending generator subprocesses that builds the frames.  The generator sends the data back
            through queues, which is then stored and drawn.
                generator           --> | event queue  | (let's us know a new frame is available)
                generator.new_frame --> | frame_queue  | --> self.frame  (the frame itself
            """
        try:
            self.command = Settings.commands[window_id]
            self.window_id = window_id
            self.event_queue = event_queue
            self.system_queue = system_queue
            self.frame_draw_current_queue = frame_draw_current_queue
            self.frame_draw_state_queue = frame_draw_state_queue
            self.bottom_bar_label = Settings.bottom_bar_label[window_id]
            self.draw_window_id = Settings.start_window_id
            self.interval = Settings.interval
            self.streaming = Settings.streaming[window_id]
            self.glued_to_bottom = True if self.streaming or Settings.glue_bottom[window_id] else False
            self.no_change = Settings.no_change[window_id]

            # init
            self.common_init()
            self.frame_init()
            self.event_init()
            self.initialize_generator_childprocess()

            # get windows ready
            self.draw_initialize_window()
            self.get_terminal_size()

            # tell event controller we are ready to go
            self.system_queue.put(1)

            # Start looping here
            self.main_loop()

        except:
            terminate_processes()

        # self.system_queue.put(2)

    def main_loop(self):
        timeout = min(.02, self.interval * .2)
        while True:
            # self.event expects a list, sent by another process
            try:
                # self.event is a list, [0] is the command, [1+] is options
                self.event = self.event_queue.get(block=True, timeout=timeout)

            except multiprocessing.queues.Empty:
                self.playback_interval()
                self.draw_after_resize()
            else:
                # run the appropriate self.event_choices function
                # an event can be from the event controller (new frame or keystrokes) or from child generator
                self.event_choices.get(self.event[0], "")()

    # PROCESS FRAMES ######################

    def start_new_frame(self):
        # the event controller tells all tabs it's time for a new event
        self.new_empty_frame()

        self.new_stop_time = self.event[1]
        self.frame_date_time[self.new] = self.event[2]
        self.precision = self.event[3]
        self.event_frame_count = self.event[4]

        if len(self.frame_state) == 1:
            self.next_frame_type = "first"
            self.precision = False

        self.current = len(self.frame_state) - 2
        # if self.current >= 0:
        #     if self.frame_state[self.current] == "waiting":
        #         self.frame_state[self.new] = "dropped"
        #         self.frame_length[self.new] = 0

        self.request_new_frame_from_generator()
        self.playback_new_frame()
        self.draw_live_frame()

    def new_empty_frame(self):
        # frames and heatmaps are stored in lists, so just append a new blank element to the fields
        self.frame_length.append(0)
        self.frame_state.append("waiting")
        self.heatmap_state.append("waiting")
        self.frame_date_time.append(0)
        self.new = len(self.frame_state) - 1

    def request_new_frame_from_generator(self):
        try:
            # tell the child generator to run the command and make us a new frame
            self.generator_event_queue.put([self.next_frame_type, self.new_stop_time, self.precision], timeout=Settings.timeout)
            self.next_frame_type = "normal"
        except multiprocessing.queues.Full:
            pass

    def received_new_frame_notice_from_generator(self):
        self.frame_state[self.new] = self.event[1]
        self.frame_length[self.new] = self.event[2]
        time.sleep(.001)
        self.get_and_store_frame()
        self.system_queue.put(1)

    def get_and_store_frame(self):
        new = self.new
        previous = max(0, self.new - 1)

        try:
            frame_changes, frame_line_numbers = self.generator_frame_queue.get(block=True, timeout=Settings.timeout)
        except multiprocessing.queues.Empty:
            # unable to get anything from the queue, just consider this an error and drop the frame
            self.frame_state[new] = "dropped"
            self.frame_length[new] = 0
        else:
            if self.frame_state[new] == "dropped":
                self.frame_length[new] = 0
            elif len(frame_changes) == 0:
                # TODO fix len frame_changes == 0
                pass
            elif self.frame_state[new] == "first":
                for line in frame_changes:
                    line_length = min(len(line), self.max_line_length_total)

                    if line_length > self.max_line_length:
                        self.lines.append([intern(line[:self.max_line_length]) + self.max_line_length_message])
                    else:
                        self.lines.append([intern(line)])

                    self.lines_pointers.append([0])
                    self.lines_states.append([0])
                    self.lines_lengths.append([line_length])

                    self.lines_chars.append([[] for x in range(line_length)])
                    self.lines_chars_pointers.append([[0] for x in range(line_length)])
            else:
                for counter, line_number in enumerate(frame_line_numbers):
                    line_length = min(len(frame_changes[counter]), self.max_line_length_total)

                    if line_length > self.max_line_length:
                        line = frame_changes[counter][:self.max_line_length] + self.max_line_length_message
                    else:
                        line = frame_changes[counter]

                    if line_number >= len(self.lines):
                        self.lines.append([intern(line)])
                        self.lines_pointers.append([new])
                        self.lines_states.append([2])
                        self.lines_lengths.append([line_length])

                        self.lines_chars.append([[char] for char in line])
                        self.lines_chars_pointers.append([[new] for x in range(line_length)])
                    else:
                        self.lines[line_number].append(intern(line))
                        self.lines_pointers[line_number].append(new)
                        self.lines_lengths[line_number].append(line_length)
                        self.lines_states[line_number].append(1)

                        for column, char in enumerate(line):
                            if column >= len(self.lines_chars[line_number]):
                                self.lines_chars[line_number].append([char])
                                self.lines_chars_pointers[line_number].append([new])
                            elif column >= self.lines_lengths[line_number][-2]:
                                self.lines_chars[line_number][column].append(char)
                                self.lines_chars_pointers[line_number][column].append(new)
                            elif line_number >= self.frame_length[previous]:
                                self.lines_chars[line_number][column].append(char)
                                self.lines_chars_pointers[line_number][column].append(new)
                            else:
                                if self.lines_chars_pointers[line_number][column][-1] == 0:
                                    last_char = self.lines[line_number][0][column]
                                else:
                                    last_char = self.lines_chars[line_number][column][-1]
                                if last_char != char:
                                    self.lines_chars[line_number][column].append(char)
                                    self.lines_chars_pointers[line_number][column].append(new)

    # DRAW FRAMES ######################

    def toggle_recording(self):
        self.recording_state = self.event[1]
        if self.recording_state == "record":
            self.draw_state = "play"
        else:
            self.draw_state = "pause"
            if self.streaming:
                try:
                    self.generator_event_queue.put(["pause", None, None],
                                                   timeout=Settings.timeout)
                except multiprocessing.queues.Full:
                    pass

        self.draw_live_frame()

    def toggle_change(self):
        if self.no_change == False:
            self.no_change = True
        else:
            self.no_change = False
        self.draw_live_frame()

    def clear_history(self):
        # self.heatmap_type = normal, first, full, refresh, ignore, noheatmap
        for counter in range(self.draw_current, len(self.frame_state)):
            if self.heatmap_state[counter] == "refresh":
                break
            self.heatmap_state[counter] = "nohistory"
        if self.heatmap_state[counter] != "refresh":
            self.next_heatmap_type = "refresh"
        self.draw_live_frame()

    def draw_initialize_window(self):
        # create a new curses window
        if Debug.debug_text_only is False:
            self.window = curses.newwin(0, 0)
            self.window.nodelay(1)
            self.window.keypad(True)

    def window_change(self):
        self.draw_window_id = self.event[1]
        if self.event[2] == "new":
            self.draw_current = self.frame_draw_current_queue.value
            self.draw_state = "play" if self.frame_draw_state_queue.value else "pause"
            self.draw_live_frame()
        else:
            self.frame_draw_current_queue.value = self.draw_current
            self.frame_draw_state_queue.value = 1 if self.draw_state == "play" else 0

    def playback_interval(self):
        if self.window_id != self.draw_window_id:
            return
        elif self.draw_state == "pause":
            return
        elif self.draw_current == self.current:
            return
        elif timeit.default_timer() < self.next_playback:
            return
        elif self.recording_state == "stop":
            pass
        elif self.playback_speed == 1:
            return
        self.next_playback = timeit.default_timer() + (self.playback_speed * self.interval)
        self.draw_current += 1
        self.frame_draw_current_queue.value = self.draw_current
        self.frame_draw_state_queue.value = 1 if self.draw_state == "play" else 0
        self.draw_live_frame()

    def playback_new_frame(self):
        if self.window_id != self.draw_window_id:
            return
        elif self.recording_state == "stop":
            return
        elif self.playback_speed != 1:
            pass
        elif self.draw_state == "play":
            self.draw_current += 1
        self.frame_draw_current_queue.value = self.draw_current
        self.frame_draw_state_queue.value = 1 if self.draw_state == "play" else 0

    def set_playback_speed(self):
        # TODO enhance: finish this.  make global to all frame controllers
        return

        # speed = self.event[1]
        # if speed == "slower":
        #     if self.playback_speed == 4.0:
        #         pass
        #     self.playback_speed *= 2.0
        # if speed == "faster":
        #     if self.playback_speed == 1.0 and self.interval <= .1:
        #         pass
        #     if self.playback_speed == .25:
        #         pass
        #     self.playback_speed /= 2.0

    def get_terminal_size(self):
        self.terminal_draw_height = self.terminal_height - self.draw_height_adder
        self.terminal_draw_width = self.terminal_width - self.draw_width_adder

        height = self.terminal_height
        width = self.terminal_width

        self.terminal_height, self.terminal_width = self.window.getmaxyx()

        if height != self.terminal_height or width != self.terminal_width:
            self.window.resize(self.terminal_height, self.terminal_width)
            # curses doesn't redraw well, use self.resize to force a few extra redraw loops
            self.resize = 5
            return True

    def draw_after_resize(self):
        if self.resize in (2, 4):
            # this is because curses is buggy on window resize and we need to redraw several times
            # whenever there is window resize event
            self.resize -= 1
            self.draw_live_frame()
        else:
            self.resize -= 1

    def draw_refresh(self):
        self.draw_live_frame()

    def draw_state_toggle(self):
        if self.draw_state == "play":
            self.draw_state = "pause"
        else:
            self.draw_state = "play"
        self.draw_live_frame()

    def draw_back(self):
        amount = self.event[1]
        if amount == 0:
            self.draw_current = 0
        else:
            self.draw_current = max(0, self.draw_current - amount)
        self.draw_state = "pause"
        self.draw_live_frame()

    def draw_forward(self):
        amount = self.event[1]
        if amount == 0:
            self.draw_current = self.current
        else:
            self.draw_current = min(self.current, self.draw_current + amount)
        if self.draw_current == self.current:
            self.draw_state = "play"
        else:
            self.draw_state = "pause"
        self.draw_live_frame()

    def move_window(self):
        self.get_terminal_size()
        direction = self.event[1]
        amount = self.event[2]

        if direction == "down":
            if amount == "one":
                self.draw_move = 1
            elif amount == "page":
                self.draw_move = self.terminal_draw_height
            elif amount == "half":
                self.draw_move = int(self.terminal_draw_height / 2)
            elif amount == "bottom":
                self.glued_to_bottom = True

        if direction == "up":
            self.glued_to_bottom = False
            if amount == "one":
                self.draw_move = -1
            elif amount == "half":
                self.draw_move = -int(self.terminal_draw_height / 2)
            elif amount == "page":
                self.draw_move = -self.terminal_draw_height
            elif amount == "top":
                self.y_top_line = 0
                self.y_top_sub = 0

        self.draw_live_frame()

    def line_wrap(self):
        draw_current = self.draw_current
        # TODO fix
        if draw_current == self.draw_current:
            live = True
        else:
            live = False
        bottom = None

        self.wrapped_lines = []

        if self.glued_to_bottom:
            t1 = timeit.default_timer()
            counter = 0
            start = max(0, self.frame_length[draw_current] - (2 * self.terminal_draw_height))
            start = self.frame_length[draw_current] - 1
            # for line_number in range(start, self.frame_length[draw_current]):
            for line_number in range(start, -1, -1):
                position = -1
                if not live:
                    position = bisect.bisect(self.lines_pointers[line_number], draw_current) - 1

                    # TODO: grep / filter out items here
                    # if x not in self.lines[line_number]:
                    #    continue

                subs = (self.lines_lengths[line_number][position] // self.terminal_draw_width)
                for sub in range(subs + 1):
                    self.wrapped_lines.append([line_number, sub])
                    counter += 1

                if counter > self.terminal_draw_height + 1:
                    break

            self.wrapped_lines.reverse()

            if len(self.wrapped_lines) > self.terminal_draw_height:
                self.wrapped_top = len(self.wrapped_lines) - self.terminal_draw_height
            else:
                self.wrapped_top = 0
                # Debug.debug_to_file(self.wrapped_lines, self.wrapped_top, self.terminal_draw_height)
            self.y_top_line = self.wrapped_lines[self.wrapped_top][0]
            self.y_top_sub = self.wrapped_lines[self.wrapped_top][1]
            self.wrapped_lines.reverse()
            # Debug.debug_to_file(timeit.default_timer() - t1, counter)
        else:
            if self.y_top_line < 0:
                self.y_top_line = 0
                self.y_top_sub = 0
            elif self.y_top_line >= self.frame_length[draw_current]:
                self.y_top_line = self.frame_length[draw_current] - 1
                self.y_top_sub = 0

            if self.y_top_sub > 0:
                # the line may have shrunk on this frame and self.y_top_subs may be to big, correct if needed
                position = -1
                if not live:
                    position = bisect.bisect(self.lines_pointers[self.y_top_line], draw_current) - 1

                subs = (self.lines_lengths[self.y_top_line][position] // self.terminal_draw_width)
                if self.y_top_sub > subs:
                    self.y_top_sub = subs

            if self.draw_move != 0:
                start = max(0, self.y_top_line - self.terminal_draw_height)
                end = min(self.frame_length[draw_current], self.y_top_line + (self.terminal_draw_height * 2))
                for line_number in range(start, end):
                    position = -1
                    if not live:
                        position = bisect.bisect(self.lines_pointers[line_number], draw_current) - 1

                    subs = (self.lines_lengths[line_number][position] // self.terminal_draw_width)
                    for sub in range(subs + 1):
                        self.wrapped_lines.append([line_number, sub])

                    if line_number == self.frame_length[draw_current] - 1:
                        bottom = len(self.wrapped_lines) - 1

                # Debug.debug_to_file("wrapped lines subs", self.wrapped_lines)
                self.wrapped_top = self.wrapped_lines.index([self.y_top_line, self.y_top_sub])

                if self.draw_move < 0:
                    # Debug.debug_to_file("wrapped top1", self.wrapped_top)
                    self.wrapped_top = max(0, self.wrapped_top + self.draw_move)
                    # Debug.debug_to_file("draw_move", self.draw_move)
                else:
                    # Debug.debug_to_file("wrapped lines len", len(self.wrapped_lines))
                    if len(self.wrapped_lines) > self.terminal_draw_height:
                        self.wrapped_top = min(len(self.wrapped_lines) - 1, self.wrapped_top + self.draw_move)
                        # Debug.debug_to_file("wrapped top1", self.wrapped_top)
                        self.wrapped_bottom = min(len(self.wrapped_lines) - 1,
                                                  self.wrapped_top + self.terminal_draw_height - 1)
                        # Debug.debug_to_file("wrapped top2", self.wrapped_top)
                        self.wrapped_top = self.wrapped_bottom - self.terminal_draw_height + 1

                        if self.wrapped_bottom == bottom:
                            self.glued_to_bottom = True
                    else:
                        self.wrapped_top = 0
                        self.glued_to_bottom = True

                self.y_top_line = self.wrapped_lines[self.wrapped_top][0]
                self.y_top_sub = self.wrapped_lines[self.wrapped_top][1]
        self.draw_move = 0
        # Debug.debug_to_file("y top line", self.y_top_line)
        # Debug.debug_to_file("y top sub", self.y_top_sub)

    def draw_live_frame(self):
        if self.window_id != self.draw_window_id:
            return

        self.window.clear()

        self.draw_height_adder = 1
        self.draw_width_adder = 0
        self.get_terminal_size()

        draw_current = self.draw_current

        if self.current < 0 or len(self.frame_state) == 0:
            status_bar, color_pair = self.build_status_bar()
        elif self.frame_state[draw_current] == "dropped":
            if self.precision is True:
                self.window.addstr("Command could not complete in time, frame dropped.")
            else:
                self.window.addstr("Error processing frame, frame dropped.")
            status_bar, color_pair = self.build_status_bar()
        elif self.frame_length[draw_current] == 0:
            status_bar, color_pair = self.build_status_bar()
        else:

            self.line_wrap()

            draw_start = self.y_top_line
            draw_end = min(self.frame_length[draw_current], self.y_top_line + self.terminal_draw_height)
            live = True if draw_current == self.current else False

            try:
                for line_number in range(draw_start, draw_end):

                    position = -1
                    if not live:
                        position = bisect.bisect(self.lines_pointers[line_number], draw_current) - 1
                    pointer = self.lines_pointers[line_number][position]

                    line_start = 0
                    if line_number == self.y_top_line:
                        line_start = self.y_top_sub * self.terminal_draw_width

                    line = self.lines[line_number][position]
                    line_length = self.lines_lengths[line_number][position]
                    line_state = self.lines_states[line_number][position]

                    if line_state == 0 or self.no_change:
                        self.window.addstr(line[line_start:], curses.color_pair(0))
                    elif line_state == 2:
                        if pointer == draw_current:
                            color = 2
                        else:
                            color = 1
                        color_pair = curses.color_pair(color)
                        self.window.addstr(line[line_start:], color_pair)
                    else:
                        for column in range(line_start, line_length):
                            try:
                                char = line[column]
                            except IndexError:
                                char = "?"

                            # NEED TO DO CHAR TO CAHR LAST

                            position = -1
                            if not live:
                                position = bisect.bisect(self.lines_chars_pointers[line_number][column], draw_current) - 1
                            pointer = self.lines_chars_pointers[line_number][column][position]

                            try:
                                color = 0
                                if pointer == 0:
                                    pass
                                elif pointer == draw_current:
                                    color = 2
                                else:
                                    color = 1
                            except (IndexError, ValueError):
                                pass
                            color_pair = curses.color_pair(color)

                            self.window.addstr(char, color_pair)

                    self.window.addstr("\n")

            except curses.error:
                pass

            status_bar, color_pair = self.build_status_bar(draw_start, draw_end, self.frame_length[draw_current])

        line_number = self.terminal_height - 1
        for column in range(self.terminal_width - 1):
            # need the -1 because of a bug in curses, it sticks a \n on the end of the last line
            try:
                char = str(status_bar[column])
            except IndexError:
                char = " "
            self.window.addstr(line_number, column, char, color_pair)
        self.window.addstr(line_number, column, " ", color_pair)
        self.window.insstr(line_number, column, " ", color_pair)

        self.window.refresh()

    def build_status_bar(self, draw_start=-1, draw_end=0, frame_height=0):
        if len(self.frame_state) == 0:
            date_time = "  :  :  .   "
        elif self.current < 0:
            date_time = self.frame_date_time[self.current + 1].strftime("%H:%M:%S.%f")
        else:
            date_time = self.frame_date_time[self.draw_current].strftime("%H:%M:%S.%f")

        mode_text = {
            "waiting"      : ["Waiting for first frame", curses.color_pair(31)],
            "paused"       : ["|| PAUSED  ", curses.color_pair(33)],
            "paused stop"  : ["|| PAUSED  ", curses.color_pair(34)],
            "playback"     : [">> PLAYBACK", curses.color_pair(32)],
            "live play"    : ["<> LIVE    ", curses.color_pair(31)],
            "live stop"    : ["<> LIVE    ", curses.color_pair(34)],
            "recording"    : [" (STOPPED)", ""],
            "not recording": ["", ""],
        }

        if self.current < 0:
            mode = "waiting"
        elif self.draw_state == "pause" and self.recording_state == "stop":
            mode = "paused stop"
        elif self.draw_state == "pause":
            mode = "paused"
        elif self.draw_current < self.current:
            mode = "playback"
        elif self.draw_state == "play" and self.recording_state == "stop":
            mode = "live stop"
        elif self.draw_state == "play":
            mode = "live play"

        if self.recording_state == "stop":
            recording_mode = "recording"
        else:
            recording_mode = "not recording"

        p = " {:>2} | {:.12} | {} |{} {}/{} ( {}-{}/{} Lines ) | {}"
        status_bar = p.format(
            self.draw_window_id + 1,
            date_time,
            mode_text[mode][0],
            mode_text[recording_mode][0],
            max(0, self.draw_current + 1),
            max(0, self.current + 1),
            max(0, draw_start + 1),
            max(0, min(draw_end, frame_height)),
            frame_height,
            self.bottom_bar_label)
        return status_bar, mode_text[mode][1]

    def write_to_file(self):
        run_file = self.event[1]

        try:
            if Settings.run_compression:
                with bz2.BZ2File(run_file, 'ab') as f:
                    pickle.dump(self, f, protocol=2)
            else:
                with open(run_file, 'ab') as f:
                    pickle.dump(self, f, protocol=2)
        except FileNotFoundError:
            # TODO add failed message, remove started file
            pass
            # except:
            # TODO add failed message, remove started file
            pass


class FrameControllersStatic(FrameControllers):
    """
    Run or display once and not again. use self.get_output() to control first frame output
    """

    def initialize_generator_childprocess(self):
        pass

    def start_new_frame(self):
        self.frame_length.append(0)
        self.frame_state.append("unchanged")
        self.heatmap_state.append("unchanged")
        self.frame_date_time.append(self.event[2])
        self.event_frame_count = self.event[4]

        self.new = len(self.frame_state) - 1
        self.current = len(self.frame_state) - 2

        self.get_and_store_frame()

        time.sleep(.001)
        self.system_queue.put(1)

        self.playback_new_frame()
        self.draw_live_frame()

    def new_empty_frame(self):
        pass

    def request_new_frame_from_generator(self):
        pass

    def received_new_frame_notice_from_generator(self):
        pass

    def get_and_store_frame(self):
        if len(self.frame_state) == 1:

            frame = self.get_output()

            for line in frame:
                if line is not None:
                    line_length = len(line)

                    self.lines.append([intern(line)])
                    self.lines_pointers.append([0])
                    self.lines_states.append([0])
                    self.lines_lengths.append([line_length])

                    self.lines_chars.append([[] for x in range(line_length)])
                    self.lines_chars_pointers.append([[0] for x in range(line_length)])

            self.frame_state[self.new] = "first"
            self.heatmap_state[self.new] = "first"
            self.frame_length[self.new] = len(self.lines)
        else:
            # expects the length to be the same even if there are no changes
            self.frame_length[self.new] = self.frame_length[0]

    def get_output(self):
        # return any list of strings
        frame = []
        return frame

    def toggle_change(self):
        pass

    def clear_history(self):
        pass


class FrameControllersHelp(FrameControllersStatic):

    def get_output(self):
        help = Settings._help.splitlines()
        help += ["", "Tabs and Commands:"]
        help += ["      {}".format(x) for x in Settings.commands_assigned if x is not None]
        commands_unassigned = [x for x in Settings.commands_unassigned if x]
        if commands_unassigned:
            help += ["", "Unassigned Commands:"]
            help += ["      {}".format(x) for x in commands_unassigned if x]
        help = ["  {}".format(x) for x in help if x is not None]
        return help


class FrameControllersNoChange(FrameControllers):
    """TODO future home of not recording changes for performance"""
    pass


class FrameControllersSavedRun(FrameControllers):
    """TODO future home of saved runs"""

    def frame_init(self):
        self.draw_current = len(self.frame_state) - 1
        self.current = self.draw_current
        self.frame_draw_current_queue.value = self.draw_current
        self.draw_state = "pause"
        self.frame_draw_state_queue.value = 1 if self.draw_state == "play" else 0
        self.recording_state = "stop"

    def initialize_generator_childprocess(self):
        pass


class FrameControllersSavedRunNoChane(FrameControllersSavedRun, FrameControllersNoChange):
    """TODO future home of saved runs and no changes"""
    pass

# ======================================================================================================================
#   Frame Generator, running, reading, storing a command
# ======================================================================================================================

class FrameGenerators(object):

    def generator_controller(self, command, frame_queue, generator_event_queue, event_queue, streaming):
        try:
            self.frame = [[], []]
            self.frame_line_numbers = []
            self.frame_state = None
            self.frame_changes = []
            self.frame_length = [0, 0]
            self.frame_stream_length = 0

            self.command = command
            self.frame_queue = frame_queue
            self.generator_event_queue = generator_event_queue
            self.event_queue = event_queue
            self.command_gid = None
            self.proc = None
            self.generator_event = None

            self.streaming = streaming
            self.precision = False
            self.current = 0
            self.last = 1
            self.frame_type = "first"
            self.stop_time = 0
            self.recording_state = "record"

            while True:

                # frame_controller sends us the parameters for this new frame
                self.generator_event = self.generator_event_queue.get(block=True)
                # self.frame_type = normal, full, first, stop, start
                self.frame_type = self.generator_event[0]
                self.stop_time = self.generator_event[1]
                self.precision = self.generator_event[2]

                if self.frame_type == "pause":
                    self.recording_state = "pause"
                    if self.streaming:
                        self.pause_gid(self.command_gid)
                        continue
                if self.streaming:
                    if self.recording_state == "pause":
                        self.continue_gid(self.command_gid)
                        self.recording_state = "record"
                    if self.frame_type == "first":
                        self.frame_generator_streaming_first()
                    self.frame_generator_streaming()
                else:
                    if self.recording_state == "pause":
                        self.recording_state = "record"
                    self.frame_generator()
                    self.frame_pre_change()
                    if self.precision is True and self.stop_time < timeit.default_timer():
                        self.dropped()

                self.put_queues()

        except:
            # continue any paused processes before quiting
            self.continue_gid(self.command_gid)
            self.terminate_gid(self.command_gid)
            terminate_processes()

    def dropped(self):
        self.command_gid = 0
        self.frame_state = "dropped"
        self.frame_length[self.current] = 0
        self.frame_changes = []

    def pause_gid(self, gid):
        term_sig = 19
        gid = 0 if gid is None else gid
        try:
            os.killpg(gid, term_sig)
        except OSError:
            pass

    def continue_gid(self, gid):
        term_sig = 18
        gid = 0 if gid is None else gid
        try:
            os.killpg(gid, term_sig)
        except OSError:
            pass

    def terminate_gid(self, gid):
        term_sig = 15
        gid = 0 if gid is None else gid
        try:
            os.killpg(gid, term_sig)
        except OSError:
            pass
        self.frame_state = "dropped"

    def run_command(self):
        terminal_width = str(int(run_linux("tput cols")[0]) - 2)
        env = dict(os.environ, COLUMNS=terminal_width)

        proc = subprocess.Popen(
            self.command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
            env=env,
            universal_newlines=True,
            preexec_fn=os.setsid
        )
        self.command_gid = os.getpgid(proc.pid)

        return proc

    # Streaming Generator starts here ####################

    def frame_generator_streaming_first(self):
        self.proc = self.run_command()
        fl_out = fcntl.fcntl(self.proc.stdout, fcntl.F_GETFL)
        fl_err = fcntl.fcntl(self.proc.stderr, fcntl.F_GETFL)
        fcntl.fcntl(self.proc.stdout, fcntl.F_SETFL, fl_out | os.O_NONBLOCK)
        fcntl.fcntl(self.proc.stderr, fcntl.F_SETFL, fl_err | os.O_NONBLOCK)

    def frame_generator_streaming(self):
        safe_margin = .0001
        end_timer = max(0, self.stop_time - timeit.default_timer() - safe_margin)
        time.sleep(end_timer)

        try:
            result = self.proc.stdout.read()
        except TypeError:
            result = ""
        try:
            error = self.proc.stderr.read()
        except (TypeError, IOError):
            error = ""

        try:
            self.frame[self.current] = result.splitlines()
            self.frame[self.current] += error.splitlines()
        except (AttributeError, UnicodeDecodeError):
            self.frame[self.current] = str(result).splitlines()
            self.frame[self.current] = str(error).splitlines()


        if self.frame_type == "first":
            self.frame_state = "first"
            self.frame_line_numbers = []
        elif not self.frame[self.current]:
            self.frame_state = "unchanged"
            self.frame_changes = []
            self.frame_line_numbers = []
        else:
            self.frame_state = "changed"
            self.frame_changes = self.frame[self.current]
            self.frame_line_numbers = list(
                range(self.frame_stream_length, self.frame_stream_length + len(self.frame[self.current])))

        self.frame_stream_length += len(self.frame[self.current])
        self.frame_length[self.current] = self.frame_stream_length

    # Non Streaming Generator starts here ####################

    def frame_generator(self):
        """ a frame is composed of a line by line list of the output from
            the assigned command for this window """

        self.proc = self.run_command()

        safe_margin = .0001
        if self.precision is True:
            end_timer = max(0, self.stop_time - timeit.default_timer() - safe_margin)

            if end_timer > 0:
                timer = threading.Timer(end_timer, self.terminate_gid, args=(self.command_gid,))
                timer.start()

                result, error = self.proc.communicate()
                timer.cancel()
            else:
                # already missed our window before we even ran the command
                self.frame_state = "dropped"

            if self.frame_state == "dropped":
                self.dropped()
                return
        else:
            result, error = self.proc.communicate()

        if self.precision is True and self.stop_time < timeit.default_timer():
            self.dropped()
            return

        # break result into a line by line list, for python 2/3
        # TODO fix: imporve stderr
        # don't keep ends because in python 3 it could different ends, and we only want /n
        try:
            self.frame[self.current] = result.splitlines()
            self.frame[self.current] += error.splitlines()
        except (AttributeError, UnicodeDecodeError):
            self.frame[self.current] = ""
            self.frame[self.current] = str(result).splitlines()
            self.frame[self.current] = str(error).splitlines()

        if self.precision is True and self.stop_time < timeit.default_timer():
            self.dropped()
            return

    def frame_pre_change(self):
        self.frame_length[self.current] = len(self.frame[self.current])

        if self.frame_type == "first":
            self.frame_line_numbers = []
            self.frame_state = "first"
        elif self.frame_length[self.current] != self.frame_length[self.last]:
            self.frame_change()
        elif self.frame[self.current] != self.frame[self.last]:
            self.frame_change()
        else:
            self.frame_state = "unchanged"
            self.frame_changes = []
            self.frame_line_numbers = []

        if self.precision is True and self.stop_time < timeit.default_timer():
            self.dropped()

    def frame_change(self):
        self.frame_state = "changed"
        self.frame_changes = []
        self.frame_line_numbers = []
        for line_number, line in enumerate(self.frame[self.current]):
            try:
                if line != self.frame[self.last][line_number]:
                    self.frame_changes.append(line)
                    self.frame_line_numbers.append(line_number)
            except IndexError:
                self.frame_changes.append(line)
                self.frame_line_numbers.append(line_number)

    # Put queues #########################

    def put_queues(self):
        try:
            if self.frame_state == "first":
                self.frame_queue.put(
                    (self.frame[self.current], self.frame_line_numbers),
                    timeout=Settings.timeout)
            else:
                self.frame_queue.put(
                    (self.frame_changes, self.frame_line_numbers),
                    timeout=Settings.timeout)
        except multiprocessing.queues.Full:
            # missed the timout, that's ok, if nothing in the queue the receiver will just call it dropped
            pass

        self.event_queue.put([
            "new frame",
            self.frame_state,
            self.frame_length[self.current]])

        if self.frame_state != "dropped":
            if self.current == 0:
                self.current = 1
                self.last = 0
            else:
                self.current = 0
                self.last = 1


# ======================================================================================================================
#   Event Controller, key presses
# ======================================================================================================================

class EventController(object):

    def __init__(self):
        self.key_mapping()

    def event_controller(self, window, event_queues, system_queues, frame_count):
        try:
            self.window = window
            self.draw_window_id = Settings.start_window_id
            self.event_queues = event_queues
            self.system_queues = system_queues
            self.draw_window_ids = Settings.window_ids + [Settings.window_id_help]
            self.start_time = timeit.default_timer()
            self.precision = Settings.precision
            self.new_stop_time = 0
            self.new_start_date_time = 0
            self.done_count = 0
            self.event_frame_count = frame_count
            self.help = False
            self.last_tab = self.draw_window_id
            if Settings.load_saved_run:
                self.recording_state = "stop"
            else:
                self.recording_state = "record"

            # start here
            while True:
                # if step is too low performance will suffer
                step = min(.02, Settings.interval * .2)
                time.sleep(step)

                # we will give the tabs a stop time, tell them to start, wait to hear they all done, repeat
                # if precision = true they should finish on time
                if timeit.default_timer() > self.new_stop_time and self.recording_state == "record":
                    if self.done_count >= len(self.draw_window_ids):
                        self.done_count = 0
                        self.new_stop_time = Settings.interval + timeit.default_timer()
                        self.new_start_date_time = datetime.datetime.now()

                        for window_id in self.draw_window_ids:
                            event_queues[window_id].put(["start new frame",
                                                         self.new_stop_time,
                                                         self.new_start_date_time,
                                                         self.precision,
                                                         self.event_frame_count])
                        self.event_frame_count += 1
                    else:
                        for draw_window_id in self.draw_window_ids:
                            # collect "frame done" from the frame controllers
                            try:
                                x = int(self.system_queues[draw_window_id].get(block=False))
                                self.done_count += 1 if x == 1 else 0
                            except multiprocessing.queues.Empty:
                                pass

                # look for a keyboard input now
                self.keyboard_input()

        except:
            terminate_processes()

    def key_mapping(self):
        self.key_map = {
            ord(" ")          : ["one", "toggle draw state"],

            # ord("-")          : ["one", "playback speed", "slower"],
            # ord("_")          : ["one", "playback speed", "slower"],
            # ord("+")          : ["one", "playback speed", "faster"],
            # ord("=")          : ["one", "playback speed", "faster"],

            curses.KEY_LEFT   : ["one", "back", 1],  # left-arrow
            ord("s")          : ["one", "back", 1],
            393               : ["one", "back", 10],  # shf-left-arror
            ord("a")          : ["one", "back", 10],
            552               : ["one", "back", 100],  # alt-shf-left-arrow
            546               : ["one", "back", 100],  # ctrl-left-arrow
            ord("A")          : ["one", "back", 100],
            ord("w")          : ["one", "back", 0],

            curses.KEY_RIGHT  : ["one", "forward", 1],  # right-arrow
            ord("d")          : ["one", "forward", 1],
            402               : ["one", "forward", 10],  # shf-right-arrow
            ord("f")          : ["one", "forward", 10],
            567               : ["one", "forward", 100],  # alt-shf-right-arrow
            561               : ["one", "forward", 100],  # ctrl-right-arrow
            ord("F")          : ["one", "forward", 100],
            ord("e")          : ["one", "forward", 0],

            curses.KEY_DOWN   : ["one", "window move", "down", "one"],
            ord("j")          : ["one", "window move", "down", "one"],
            4                 : ["one", "window move", "down", "half"],  # ctrl-d
            336               : ["one", "window move", "down", "page"],  # shift-down
            curses.KEY_NPAGE  : ["one", "window move", "down", "page"],  # page down
            6                 : ["one", "window move", "down", "page"],  # ctrl-f
            ord("G")          : ["one", "window move", "down", "bottom"],
            curses.KEY_END    : ["one", "window move", "down", "bottom"],
            526               : ["one", "window move", "down", "bottom"],  # ctrl-down

            curses.KEY_UP     : ["one", "window move", "up", "one"],
            ord("k")          : ["one", "window move", "up", "one"],
            21                : ["one", "window move", "up", "half"],  # ctrl-u
            337               : ["one", "window move", "up", "page"],  # shift-up
            curses.KEY_PPAGE  : ["one", "window move", "up", "page"],  # page up
            2                 : ["one", "window move", "up", "page"],  # ctrl-b
            ord("g")          : ["one", "window move", "up", "top"],
            curses.KEY_HOME   : ["one", "window move", "up", "top"],
            567               : ["one", "window move", "up", "top"],  # crtl-up

            ord("x")          : ["one", "toggle change"],
            ord("X")          : ["one", "clear history"]
        }
        self.tab_map = {ord("1"): 0, ord("2"): 1, ord("3"): 2, ord("4"): 3, ord("5"): 4, ord("6"): 5, ord("7"): 6,
                        ord("8"): 7, ord("9"): 8, ord("0"): 9, ord("!"): 10, ord("@"): 11, ord("#"): 12, ord("$"): 13,
                        ord("%"): 14, ord("^"): 15, ord("&"): 16, ord("*"): 17, ord("("): 18, ord(")"): 19,
                        8: Settings.window_id_help}

    def keyboard_input(self, raw_keystroke=0):
        self.window.nodelay(1)
        if raw_keystroke == 0:
            raw_keystroke = self.window.getch()

        if raw_keystroke != -1:
            # to see keystroke codes uncomment this line and tail -f debug on the commond line
            # Debug.debug_to_file("raw: " + str(raw_keystroke)  )
            pass

        if raw_keystroke == curses.KEY_RESIZE:
            # window resize event occurred
            self.event_queues[self.draw_window_id].put(("refresh",))

        if self.draw_window_id == Settings.window_id_help:
            if raw_keystroke == 8 or raw_keystroke == 27:
                # ctrl-h or [esc], toggle out of help. Fake a key press for the last tab
                raw_keystroke = [key for key, w_id in self.tab_map.items() if w_id == self.last_tab][0]

        if raw_keystroke in self.tab_map:
            # switch tabs
            new_win = self.tab_map[raw_keystroke]
            if Settings.commands[new_win] and new_win != self.draw_window_id:
                try:
                    self.event_queues[self.draw_window_id].put(("window change", new_win, "close"), timeout=Settings.timeout)
                    self.last_tab = self.draw_window_id
                    self.draw_window_id = new_win
                    self.event_queues[self.draw_window_id].put(("window change", new_win, "new"), timeout=Settings.timeout)
                except multiprocessing.queues.Full:
                    pass

        if raw_keystroke == ord("r") and not Settings.load_saved_run:
            # stop / start recording
            if self.recording_state == "record":
                self.recording_state = "stop"
                self.key_map[ord("r")] = ["all", "toggle recording", "stop"]
            else:
                self.recording_state = "record"
                self.key_map[ord("r")] = ["all", "toggle recording", "record"]
                self.new_stop_time = 0

        if raw_keystroke in self.key_map:
            # move, frames, etc
            if self.key_map[raw_keystroke][0] == "all":
                win = self.draw_window_ids
            else:
                win = [self.draw_window_id]
            instruction = self.key_map[raw_keystroke][1:]

            self.send_event(instruction, win)

        if raw_keystroke == 23:
            # ctrl-w
            self.write_to_file()

        # TODO sleeping processes are not quiting with q, so use ctrl-c for now
        # if raw_keystroke == ord("q"):
        #     sys.exc_clear()
        #     terminate_processes()

    def send_event(self, instruction, win):
        for window_id in win:
            try:
                self.event_queues[window_id].put(instruction, timeout=Settings.timeout)
            except multiprocessing.queues.Full:
                pass

    def write_to_file(self):
        # first need to stop recording
        temp_recording_state = self.recording_state
        if self.recording_state == "record":
            self.recording_state = "stop"
            self.send_event(["toggle recording", "stop"], self.draw_window_ids)
            time.sleep(.1)

        # make a filename
        file_base = str(datetime.datetime.now().date()) + "-" + \
                   str(datetime.datetime.now().time()).split(".")[0].replace(":", "-") + \
                   ".wp"
        filename = file_base
        add_count = 0
        while True:
            if os.path.exists("{}/{}".format(Settings.run_path, filename)):
                add_count += 1
                filename = file_base.replace(".wp", "_" + str(add_count) + ".wp")
                continue
            break
        run_file = "{}/{}".format(Settings.run_path, filename)

        # write Setting
        try:
            if Settings.run_compression:
                with bz2.BZ2File(run_file, 'wb') as f:
                    # use () on Settings because it has no instances
                    pickle.dump(Settings(), f, protocol=2)
            else:
                with open(run_file, 'wb') as f:
                    # use () on Settings because it has no instances
                    pickle.dump(Settings(), f, protocol=2)
        except FileNotFoundError:
            # TODO add failed message, remove started file
            return
        except:
            # TODO add failed message
            return

        # tell each tab to write
        for window_id in self.draw_window_ids:
            self.send_event(["save", run_file], [window_id])
            get = 0
            for i in range(3 * 60 * 10):
                # get completed response(2), 3 minute timeout
                try:
                    get = int(self.system_queues[window_id].get(block=True, timeout=.1))
                    self.done_count += 1 if get == 1 else 0
                    if get == 2:
                        break
                except multiprocessing.queues.Empty:
                    pass
            if get != 2:
                # TODO add failed message
                return

        # turn recording back on
        if temp_recording_state == "record":
            self.recording_state = "record"
            self.new_stop_time = 0
            self.send_event(["toggle recording", "record"], self.draw_window_ids)

# ======================================================================================================================
#   Functions
# ======================================================================================================================

def new_sleep(stop_time):
    """ Curses sends a SIGWINCH to time.sleep and mp.Queue(timeout=) when the window is resized, which terminates them
        prematurely. To prevent this we must build our own timer. (This will not fix mp.Queue(timeout=))
        """
    stop = timeit.default_timer() + stop_time
    while stop >= timeit.default_timer():
        try:
            _sleep(max(0, stop - timeit.default_timer()))
        except ValueError:
            pass

def run_linux(command, stdout=subprocess.PIPE):
    result, error = subprocess.Popen(
        command,
        stdout=stdout,
        stderr=subprocess.PIPE,
        shell=True,
        universal_newlines=True).communicate()
    return result, error

def terminate_processes(message=None):
    exception = str(traceback.format_exc())
    terminate_curses()
    time.sleep(.1)
    if "KeyboardInterrupt" not in exception and "None\n" not in exception:
        print(exception)
    if message:
        print(message)
    term_sig = 15
    try:
        os.killpg(os.getpgid(0), term_sig)
    except (TypeError, OSError):
        pass
    sys.exit()

def terminate_curses():
    curses.echo()
    curses.nocbreak()
    curses.curs_set(1)
    curses.endwin()


# ======================================================================================================================
#   Main
# ======================================================================================================================

class Main(object):
    event_queues = [None] * MAX_COMMANDS
    system_queues = [None] * MAX_COMMANDS
    frame_count = 0
    frame_draw_current_queue = multiprocessing.Value("i", 0)
    frame_draw_state_queue = multiprocessing.Value("i", 0)
    process_frame_controllers = [None] * MAX_COMMANDS
    process_event_controller = None
    stdscr = None

    @classmethod
    def start_curses(cls):
        cls.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)
        cls.stdscr.keypad(True)
        curses.start_color()
        cls.curses_color_setup()

    @staticmethod
    def curses_color_setup():
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_YELLOW)
        curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_RED)
        curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_BLUE)
        curses.init_pair(31, curses.COLOR_BLACK, curses.COLOR_GREEN)
        curses.init_pair(32, curses.COLOR_BLACK, curses.COLOR_CYAN)
        curses.init_pair(33, curses.COLOR_BLACK, curses.COLOR_YELLOW)
        curses.init_pair(34, curses.COLOR_BLACK, curses.COLOR_RED)

    @classmethod
    def setup_help_tab(cls):
        """
        Help is added on to the command list and is handled like a normal command with it's
        own tab
        """
        try:
            index = Settings.commands.index("Help Screen")
        except ValueError:
            pass
        else:
            # clear out help that was imported
            del Settings.commands[index]
            del Settings.bottom_bar_label[index]
            del Settings.streaming[index]
            del Settings.glue_bottom[index]
            del Settings.no_change[index]

        Settings.commands.append("Help Screen")
        Settings.bottom_bar_label.append("Help Screen")
        Settings.streaming.append(False)
        Settings.glue_bottom.append(False)
        Settings.no_change.append(False)
        cls.event_queues.append(None)
        cls.system_queues.append(None)
        cls.process_frame_controllers.append(None)

        Settings.window_id_help = Settings.commands.index("Help Screen")

    @classmethod
    def spawn_frame_controllers(cls):
        frame_controller_seed = FrameControllers()
        for window_id in Settings.window_ids:
                cls.spawn_frame_controller(window_id, frame_controller_seed)

        # add help tab
        cls.setup_help_tab()
        frame_controller_seed = FrameControllersHelp()
        cls.spawn_frame_controller(Settings.window_id_help, frame_controller_seed)

    @classmethod
    def spawn_frame_controller(cls, window_id, frame_controller_seed):
        cls.event_queues[window_id] = multiprocessing.Queue(0)
        cls.system_queues[window_id] = multiprocessing.Queue(0)
        cls.process_frame_controllers[window_id] = multiprocessing.Process(
            target=frame_controller_seed.frame_controller,
            args=(
            window_id,
            cls.event_queues[window_id],
            cls.system_queues[window_id],
            cls.frame_draw_current_queue,
            cls.frame_draw_state_queue
        ))

    @classmethod
    def start_frame_controllers(cls):
        for window_id in Settings.window_ids:
            cls.process_frame_controllers[window_id].start()
        cls.process_frame_controllers[Settings.window_id_help].start()

    @classmethod
    def main_controller(cls):
        event_controller_seed = EventController()
        cls.process_event_controller = multiprocessing.Process(
            target=event_controller_seed.event_controller,
            args=(
                cls.stdscr,
                cls.event_queues,
                cls.system_queues,
                cls.frame_count
            ))
        cls.process_event_controller.start()
        cls.process_event_controller.join()

class MainSavedRun(Main):

    @classmethod
    def start_frame_controllers(cls):
        if Settings.run_compression:
            with bz2.BZ2File(Settings.load_run_file, 'rb') as run_file:
                cls.load_pickle(f)
        else:
            with open(Settings.load_run_file, 'rb') as run_file:
                cls.load_pickle(f)

    @classmethod
    def load_pickle(cls, run_file):
        try:
            # load Settings first
            pickle.load(run_file, fix_imports=True)
            Settings.load_saved_run = True
            Settings.start_window_id = Settings.window_ids[0]
            cls.setup_help_tab()

            # load frames
            for window_id in Settings.window_ids:
                # if we load data into a FrameController instance, then spawn the processes from that instance,
                # the instance data will be copied into the new processes
                frame_controller = pickle.load(run_file, fix_imports=True)

                # convert loaded class instance to a saved instance
                frame_controller_seed = FrameControllersSavedRun()
                frame_controller_seed.__dict__.update(frame_controller.__dict__)
                del frame_controller

                cls.frame_count = len(frame_controller.frame_state) - 1
                cls.spawn_frame_controller(window_id, frame_controller)
                del frame_controller_seed

            # add help tab
            frame_controller_seed = FrameControllersHelp()
            cls.spawn_frame_controller(Settings.window_id_help, frame_controller_seed)

        except EOFError:
            # not enough items to read in
            # make a better error message
            raise

if __name__ == "__main__":

    # make our own custom sleep
    time.sleep = new_sleep

    process_argparse()

    try:
        if Settings.load_saved_run:
            main = MainSavedRun()
        else:
            main = Main()
        main.start_curses()
        main.spawn_frame_controllers()
        main.start_frame_controllers()
        main.main_controller()
    except:
        terminate_processes()
